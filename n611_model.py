# -*- coding: utf-8 -*-
"""N611_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HzDWAzkhJVRLFQ1Zs2tHIIBE_wNMp0VC
"""

from math import e
import numpy as np
import matplotlib.pyplot as plt
!easy_install -U scikit-fuzzy
!pip install scikit-fuzzy
import skfuzzy as fuzz
from skfuzzy import control as ctrl
import random

def SolarPanel(V,I,G,PLoad):      #Voltage,Current,Radiance,Power Load
    Ki=0.05                       #Shot-circuit current at 25°C and 1000W/m^2
    Tn=298                        #Nominal temperature
    q=1.6*10**(-19)               #Electron charge
    n=0.5                         #Ideality factor of the diode
    K=1.38*10**(-23)              #Boltzmann's Constant
    Eg0=1.1                       #Band gap energy of the semiconductor
    Ns=114                        #Number of cells in series
    Np=1                          #Number of cells in parallel
    Rs=0.221                      #Series Resistance
    Rsh=415.405                   #Shunt Resistance
    Pmp=210                       #Rated power
    Vmp=18.3                      #Voltage at maximun power
    Imp=11.48                     #Current ar maximun power
    Voc=22.8                      #Open circuit voltage
    Isc=12.11                     #Short circuit current
    I=0                           #Output Current
    T=298                         #Temperature       
    #Reverse saturation current
    Irs=Isc/(e**((q*Voc)/(n*Ns*K*T))-1)
    #Saturation Current 
    Io=e**(((1/Tn-1/T)*Eg0*q)/(n*K))*Irs*(T/Tn)**3
    #Photo-current
    Iph=(Isc+Ki*(T-Tn))*(G/1000) 
    #Current through shunt resistor
    Ish=(V+Rs)/Rsh
    #Output Current
    I_out=Iph-Io*(e**((q*(V+I*Rs))/(n*K*Ns*T))-1)-Ish
    if I_out*V-PLoad>0:
        P_out=PLoad
    else: 
        P_out=I_out*V
        if P_out<=0:
          P_out=0
    return I_out,P_out

def BatterySistem(Vdc):
  if Vdc>=16:
    pass

def S1():
  pass

def Time_Flag(Hora): #Pasar solo la hora en numeros del 1 al 24
  if Hora>=8 and Hora<=16:
    flag=True
  else:
    flag=False 
  return flag

"""### MPPT por Lógica Difusa"""

error_delta = ctrl.Antecedent(np.arange(-30, 20, 0.1), 'error_delta')
voltage_delta = ctrl.Consequent(np.arange(-0.5,0.5, 0.01), 'voltage_delta')

error_delta['negative big'] = fuzz.trimf(error_delta.universe,[-30,-30, -20])
error_delta['negative medium'] = fuzz.trapmf(error_delta.universe, [-25,-20,-10, -5])
error_delta['negative small'] = fuzz.trapmf(error_delta.universe, [-8,-7,-1, -0])
error_delta['zero'] = fuzz.trapmf(error_delta.universe, [0, 1,5, 6])
error_delta['positive small'] = fuzz.trapmf(error_delta.universe, [5, 6,8, 10])
error_delta['positive medium'] = fuzz.trapmf(error_delta.universe, [8, 10,12, 15])
error_delta['positive big'] = fuzz.trapmf(error_delta.universe, [12, 15, 20, 20])
  
voltage_delta['negative big'] = fuzz.trapmf(voltage_delta.universe,[-0.5, -0.5,-0.3,-0.2])
voltage_delta['negative medium'] = fuzz.trimf(voltage_delta.universe,[-0.3,-0.2,-0.1])
voltage_delta['negative small'] = fuzz.trimf(voltage_delta.universe, [-0.2,-0.1,0])
voltage_delta['zero'] = fuzz.trimf(voltage_delta.universe, [-0.1, 0, 0.1])
voltage_delta['positive small'] = fuzz.trimf(voltage_delta.universe, [0, 0.1, 0.2])
voltage_delta['positive medium'] = fuzz.trimf(voltage_delta.universe, [0.1, 0.2, 0.3])
voltage_delta['positive big'] = fuzz.trapmf(voltage_delta.universe, [0.2, 0.3,0.5,0.5])
      
rule1 = ctrl.Rule(error_delta['negative big'], voltage_delta['negative big'])
rule2 = ctrl.Rule(error_delta['negative medium'], voltage_delta['negative medium'])
rule3 = ctrl.Rule(error_delta['negative small'], voltage_delta['negative small'])
rule4 = ctrl.Rule(error_delta['zero'], voltage_delta['zero'])
rule5 = ctrl.Rule(error_delta['positive small'], voltage_delta['positive small'])
rule6 = ctrl.Rule(error_delta['positive medium'], voltage_delta['positive medium'])
rule7 = ctrl.Rule(error_delta['positive big'], voltage_delta['positive big'])

setting_ctrl = ctrl.ControlSystem([rule1,rule2, rule3, rule4, rule5,rule6,rule7])
setting = ctrl.ControlSystemSimulation(setting_ctrl)

"""###Control de Estados"""

############Datos de Prueba para Fuzzy############
#Radiación - Vector con multiples radicaciones repetidas para poder observar la acción del fuzzy con el tiempo
Radiation_a=[]
valores=[100,200,300,400,500,600,700,800,900,1000]
for j in valores:
  for i in range(50):
    Radiation_a.append(j)
#Carga - Constante por facilidad
PowerLoad=200 #Vatios

########################################################################################################## Inicialización S1 ####################################################################################################
S=1
power_delta_a=[]
voltage_delta_a=[]
volt2affect=0
#Hacer diferencia entre potencia nominal y potencia real
Vdc=14 #Cargamos los vectores de potencia y voltage con valores iniciales y así evitar la división entre 0
(PanelCurrent,PanelPower)=SolarPanel(Vdc,0,Radiation_a[0],PowerLoad)
power_delta_a.append(PanelPower)
voltage_delta_a.append(Vdc)
Vdc=15
(PanelCurrent,PanelPower)=SolarPanel(Vdc,PanelCurrent,Radiation_a[0],PowerLoad)
power_delta_a.append(PanelPower)
voltage_delta_a.append(Vdc)
Vdc=16
#Datos a guardar
PanelPower_a=[]
PanelVoltage_a=[]

########################################################################################################## Empiza Sistema ####################################################################################################

for Radiation in Radiation_a:                   #Aquí debe ir que mientras se tengan datos de entrada
  if S==1:
        (PanelCurrent,PanelPower)=SolarPanel(Vdc,PanelCurrent,Radiation,PowerLoad)
        PanelPower_a.append(PanelPower)   #Guardamos las potencias del panel
        PanelVoltage_a.append(Vdc)        #Guardamos las tensiones del panel
        if PanelPower>=0:
            power_delta_a.pop(0)
            voltage_delta_a.pop(0)
            power_delta_a.append(PanelPower)
            voltage_delta_a.append(Vdc)
            try:
              power_error=round((power_delta_a[1]-power_delta_a[0])/(voltage_delta_a[1]-voltage_delta_a[0]),3)
            except: 
              power_error=0.01        #Como es un entorno simulado, es posible que la resta de tensiones me de 0, así que en ese caso asigno el error como uno muy pequeño
            if power_error>=30:
                power_error=30
            if power_error<=-20:
                power_error=-20
            if Time_Flag(8):
                if PanelPower<1:    #Para evitar que se atasque cuando potencia del panel=0
                    Vdc=16  #Así, si es que nos salimos de los límites, volvemos al inicio, y si no hay radiacion quedamos en una tension relativamente elevada para alimentar cargas, cargar baterias y evitar perdidas por corriente elevada
                else:
                    setting.input['error_delta'] = power_error
                    setting.compute()
                    volt2affect = round(setting.output['voltage_delta'],3)
                    if volt2affect<=0.001:
                      volt2affect=0
                    Vdc=round(Vdc+volt2affect+random.random()*random.choice([-0.5,0.5]),3)
                    if Vdc<=16:   #PONGO LÍMITES PARA LA TENSIÓN 
                      Vdc=16
                    if Vdc>=20:
                      Vdc=20
            else: 
                Vdc=16

Power100=[]
for i in range(20):
    Power100.append(PanelPower_a[i])

plt.plot(PanelPower_a)
plt.show()

"""##Curvas VI y VP del Panel Solar"""

V=np.arange(0,23.5,0.1)
G=np.arange(500,1100,100)
def SolarPanel_G(V,G):
  I=[]
  I_G=[]
  I_act=0
  P=[]
  P_G=[]
  #Grafico V vs I
  for k in G:
    I=[]
    P=[]
    I_act=0
    for j in V:
      (I_act,P_act)=SolarPanel(j,I_act,k)
      if I_act>0:
        I.append(I_act)
        P.append(P_act)
      else:
        I.append(0)
        P.append(0)
    I_G.append(I)
    P_G.append(P)

  for k in range(len(G)):
    plt.plot(V,I_G[k])
  plt.show()

  for k in range(len(G)):
    plt.plot(V,P_G[k])
  plt.show()
SolarPanel_G(V,G)